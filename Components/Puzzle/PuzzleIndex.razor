@page "/puzzle/{shareId}"
@rendermode InteractiveServer
@using Microsoft.EntityFrameworkCore
@using Connections.Data
@using Connections.Models;
@using System.Linq;
@using System.Globalization
@implements IDisposable
@inject IDbContextFactory<ConnectionsContext> DbFactory
@inject PersistentComponentState ApplicationState

<PageTitle>@puzzle?.Title</PageTitle>
<section>
	<h2>@puzzle?.Title</h2>
	<h5>Created by @puzzle?.CreatedBy</h5>
	<h5>@puzzle?.CreatedOn.ToString(DateTimeFormatInfo.CurrentInfo.LongDatePattern)</h5>
</section>
@if (tiles is not null)
{
	<div id="grid">
		@foreach (Tile tile in tiles)
		{
			<PuzzleTile Tile=@tile OnTileClick=@UpdateTilesState/>
		}
	</div>
}
<div>
	Mistakes: @mistakes
</div>
@if (gameWon)
{
	<div>You win!</div>
}
else
{
	<div>
	<button disabled=@(puzzle is null || GetSelectedTileCount() > 0) @onclick=OnShuffleClick>Shuffle</button>
	<button disabled=@(puzzle is null || GetSelectedTileCount() == 0) @onclick=OnDeselectClick>Deselect All</button>
	<button disabled=@(puzzle is null || GetSelectedTileCount() < 4) @onclick=OnSubmitClick>Submit</button>
	</div>
}


@code {
	[Parameter]
	public string ShareId { get; set; } = "";

	private Puzzle? puzzle;
	private IEnumerable<Tile>? tiles;
	private int mistakes = 0;
	private bool gameWon = false;

	private PersistingComponentStateSubscription puzzleSubscription;
	private PersistingComponentStateSubscription tilesSubscription;

	/// <summary>
	/// On page load, query pre-loaded application state for puzzle and tile data
	/// If puzzle doesn't exist, query database for puzzle and groups and persist in state
	/// If tiles don't exist, map from puzzle groups
	/// </summary>
	/// <returns></returns>
	protected override async Task OnInitializedAsync()
	{
		puzzleSubscription = ApplicationState.RegisterOnPersisting(PersistPuzzleData);
		tilesSubscription = ApplicationState.RegisterOnPersisting(PersistTilesData);

		if (ApplicationState.TryTakeFromJson<Puzzle>(nameof(puzzle), out Puzzle? restoredPuzzle))
		{
			puzzle = restoredPuzzle;
		}
		else
		{
			puzzle = await GetPuzzleAsync(ShareId);
		}

		if (ApplicationState.TryTakeFromJson<IEnumerable<Tile>>(nameof(tiles), out IEnumerable<Tile>? restoredTiles))
		{
			tiles = restoredTiles;
		}
		else
		{
			tiles = MapPuzzleTiles(puzzle);
		}
	}

	/// <summary>
	/// Query database for a puzzle and its groups
	/// </summary>
	/// <param name="shareId"></param>
	/// <returns></returns>
	private async Task<Puzzle?> GetPuzzleAsync(string shareId)
	{
		using ConnectionsContext context = DbFactory.CreateDbContext();
		return await context.Puzzles
			.Include(p => p.Groups)
			.SingleOrDefaultAsync(p => p.ShareId == shareId);
	}

	/// <summary>
	/// Map a puzzle's groups into a set of labelled shuffled tiles
	/// </summary>
	/// <returns></returns>
	private IEnumerable<Tile>? MapPuzzleTiles(Puzzle? puzzle)
	{
		return puzzle?.Groups.SelectMany(group =>
		{
			return new Tile[]
			{
				new Tile { Label = group.Member1 },
				new Tile { Label = group.Member2 },
				new Tile { Label = group.Member3 },
				new Tile { Label = group.Member4 }
			};
		})
		.OrderBy(_ => Guid.NewGuid())
		.ToList();
	}

	/// <summary>
	/// Recreate state of tiles when a tile is clicked
	/// When a tile is clicked, toggle its state from selected or deselected
	/// If it is the 4th tile to be clicked, disable all deselected tiles
	/// If deselecting a 4th tile, re-enable all disabled tiles
	/// </summary>
	/// <param name="selectedTileLabel"></param>
	private void UpdateTilesState(string selectedTileLabel)
	{
		int tilesAlreadySelected = GetSelectedTileCount();
		TileState selectedTileState = tiles!.Single(t => t.Label == selectedTileLabel).State;

		tiles = tiles!.Select(t =>
		{
			if (t.Label == selectedTileLabel)
			{
				return new Tile
				{
					Label = t.Label,
					State = t.State == TileState.DEFAULT ? TileState.SELECTED : TileState.DEFAULT,
					SolvedColour = t.SolvedColour
				};
			}

			if (tilesAlreadySelected == 3 && selectedTileState != TileState.SELECTED)
			{
				return new Tile
				{
					Label = t.Label,
					State = t.State == TileState.DEFAULT ? TileState.DISABLED : t.State,
					SolvedColour = t.SolvedColour
				};
			}

			if (tilesAlreadySelected == 4)
			{
				return new Tile
				{
					Label = t.Label,
					State = t.State == TileState.DISABLED ? TileState.DEFAULT : t.State,
					SolvedColour = t.SolvedColour
				};
			}

			return t;
		}).ToList();
	}

	/// <summary>
	/// Deselect all selected tiles
	/// </summary>
	private void OnDeselectClick()
	{
		tiles = tiles!.Select(t =>
		{
			if (t.State == TileState.SELECTED || t.State == TileState.DISABLED)
			{
				return new Tile
				{
					Label = t.Label,
					State = TileState.DEFAULT,
					SolvedColour = t.SolvedColour
				};
			}
			return t;
		}).ToList();
	}

	// <summary>
	/// Shuffle unsolved tiles
	/// </summary>
	private void OnShuffleClick()
	{
		tiles = tiles!
			.OrderBy(_ => Guid.NewGuid())
			.ToList();
	}

	/// <summary>
	/// Submit 4 selected tiles as a potential group
	/// Sets tile state to correct and colour to group difficulty if a match is found
	/// Increments mistake counter and clears grid if no match is found
	/// </summary>
	private void OnSubmitClick()
	{
		Group? matchingGroup = FindMatchingGroup(tiles!.Where(t => t.State == TileState.SELECTED));
		if (matchingGroup is null)
		{
			mistakes++;
			tiles = tiles!.Select(t =>
			{
				return new Tile
				{
					Label = t.Label,
					State = t.State == TileState.CORRECT ? TileState.CORRECT : TileState.DEFAULT,
					SolvedColour = t.SolvedColour
				};
			}).ToList();
		}
		else
		{
			tiles = RebuildTiles(matchingGroup);
			gameWon = tiles!.All(t => t.State == TileState.CORRECT);
		}
	}

	/// <summary>
	/// Validates a submitted group against the list of groups in the puzzle
	/// </summary>
	/// <returns>The group that matched the submitted tiles, or null if no group found</returns>
	private Group? FindMatchingGroup(IEnumerable<Tile> submission)
	{
		IEnumerable<string> submittedLabels = submission.Select(l => l.Label).Order();
		return puzzle!.Groups.SingleOrDefault(group =>
		{
			IEnumerable<string> groupLabels = [group.Member1, group.Member2, group.Member3, group.Member4];
			return submittedLabels.SequenceEqual(groupLabels.Order());
		});
	}

	/// <summary>
	/// Rebuilds the tiles grid after a correct submission by moving the correct
	/// tiles to the first unsolved row and swapping any elements that are in
	/// that row
	/// </summary>
	/// <param name="solvedGroup">The puzzle group that has been solved</param>
	/// <returns></returns>
	private IEnumerable<Tile> RebuildTiles(Group solvedGroup)
	{
		int solvedGroupsCount = tiles!.Count(t => t.State == TileState.CORRECT) / 4;

		List<(int idx, Tile unsolved)> idxUnsolvedToSwap = tiles!
			.Index()
			.Skip(solvedGroupsCount * 4)
			.Take(4)
			.Where(t => t.Item.State == TileState.DISABLED)
			.ToList();

		List<(int idx, Tile solved)> idxSolvedToSwap = tiles!
			.Index()
			.Skip(solvedGroupsCount * 4 + 4)
			.Where(t => t.Item.State == TileState.SELECTED)
			.ToList();

		int solvedSwaps = 0;
		int unsolvedSwaps = 0;

		return tiles!.Index().Select(t =>
		{
			// These tiles will already be solved, so leave them as-is
			if (t.Index < solvedGroupsCount * 4)
			{
				return t.Item;
			}

			// If tile is in the row we're going to move a solved tile to and is part of the
			// submission, solve it and leave it there
			if (t.Item.State == TileState.SELECTED && t.Index >= solvedGroupsCount * 4 && t.Index < solvedGroupsCount * 4 + 4)
			{
				return new Tile()
					{
						Label = t.Item.Label,
						State = TileState.CORRECT,
						SolvedColour = GetSolvedGroupColour(solvedGroup.Difficulty)
					};
			}

			// If an unsolved tile is in the row we're going to move a solved tile to,
			// we need to swap them one at a time
			if (idxUnsolvedToSwap.Select(i => i.idx).Contains(t.Index))
			{
				Tile solvedTile = new()
					{
						Label = idxSolvedToSwap.ElementAt(solvedSwaps).solved.Label,
						State = TileState.CORRECT,
						SolvedColour = GetSolvedGroupColour(solvedGroup.Difficulty)
					};
				solvedSwaps++;
				return solvedTile;
			}

			if (idxSolvedToSwap.Select(i => i.idx).Contains(t.Index))
			{
				Tile unsolvedTile = new()
					{
						Label = idxUnsolvedToSwap.ElementAt(unsolvedSwaps).unsolved.Label,
						State = TileState.DEFAULT
					};
				unsolvedSwaps++;
				return unsolvedTile;
			}

			return new Tile
				{
					Label = t.Item.Label,
					State = TileState.DEFAULT
				};
		}).ToList();
	}

	private string GetSolvedGroupColour(Difficulty difficulty) => difficulty switch
	{
		Difficulty.YELLOW => "yellow",
		Difficulty.GREEN => "green",
		Difficulty.BLUE => "blue",
		Difficulty.PURPLE => "purple",
		_ => ""
	};

	private int GetSelectedTileCount() => tiles?.Count(t => t.State == TileState.SELECTED) ?? 0;

	/// <summary>
	/// Persist queried puzzle data so it isn't set a second time after page preload
	/// </summary>
	/// <returns></returns>
	private Task PersistPuzzleData()
	{
		ApplicationState.PersistAsJson(nameof(puzzle), puzzle);
		return Task.CompletedTask;
	}

	/// <summary>
	/// Persist queried & randomised tiles data so it isn't set a second time after page preload
	/// </summary>
	/// <returns></returns>
	private Task PersistTilesData()
	{
		ApplicationState.PersistAsJson(nameof(tiles), tiles);
		return Task.CompletedTask;
	}

	void IDisposable.Dispose()
	{
		puzzleSubscription.Dispose();
		tilesSubscription.Dispose();
	}
}