@page "/puzzle/{shareId}"
@rendermode InteractiveServer
@using Microsoft.EntityFrameworkCore
@using Connections.Data
@using Connections.Models;
@using System.Linq;
@implements IDisposable
@inject IDbContextFactory<ConnectionsContext> DbFactory
@inject PersistentComponentState ApplicationState

<PageTitle>@puzzle?.Title</PageTitle>
<section>
	@foreach (Tile tile in (puzzle?.Tiles ?? []))
	{
		<PuzzleTile Tile=@tile OnTileClick=@UpdateSelectedTileState/>
	}
</section>

@code {
	[Parameter]
	public string ShareId { get; set; } = "";

	private Puzzle? puzzle;
	private int selectedTileCount = 0;
	private PersistingComponentStateSubscription persistingSubscription;

	protected override async Task OnInitializedAsync()
	{
		persistingSubscription = ApplicationState.RegisterOnPersisting(PersistPuzzleData);

		if (!ApplicationState.TryTakeFromJson<Puzzle>(nameof(puzzle), out Puzzle? restoredPuzzle))
		{
			puzzle = await GetPuzzleAsync(ShareId);
		}
		else
		{
			puzzle = restoredPuzzle;
		}
	}

	/// <summary>
	/// Query database for a puzzle and its groups
	/// </summary>
	/// <param name="shareId"></param>
	/// <returns></returns>
	private async Task<Puzzle?> GetPuzzleAsync(string shareId)
	{
		using ConnectionsContext context = DbFactory.CreateDbContext();
		Puzzle? puzzle = await context.Puzzles
			.Include(p => p.Groups)
			.SingleOrDefaultAsync(p => p.ShareId == shareId);

		if (puzzle is not null)
		{
			puzzle.Tiles = GetPuzzleTiles(puzzle);
		}

		return puzzle;
	}

	/// <summary>
	/// Map a puzzle's groups into a set of labelled shuffled tiles
	/// </summary>
	/// <returns></returns>
	private IEnumerable<Tile> GetPuzzleTiles(Puzzle puzzle)
	{
		return puzzle.Groups.SelectMany(group =>
		{
			return new Tile[]
			{
				new Tile { Label = group.Member1 },
				new Tile { Label = group.Member2 },
				new Tile { Label = group.Member3 },
				new Tile { Label = group.Member4 }
			};
		})
		.OrderBy(_ => Guid.NewGuid())
		.ToList();
	}

	/// <summary>
	/// When a tile is clicked, toggle its state from selected or deselected
	/// If it is the 4th tile to be clicked, disable all deselected tiles
	/// If deselecting a 4th tile, re-enable all disabled tiles
	/// </summary>
	/// <param name="selectedTileLabel"></param>
	private void UpdateSelectedTileState(string selectedTileLabel)
	{
		Tile selectedTile = puzzle!.Tiles.Single(t => t.Label == selectedTileLabel);

		if (selectedTile.State == TileState.DEFAULT)
		{
			selectedTileCount++;
			selectedTile.State = TileState.SELECTED;
		}
		else if (selectedTile.State == TileState.SELECTED)
		{
			selectedTileCount--;
			selectedTile.State = TileState.DEFAULT;
		}

		if (selectedTileCount >= 4)
		{
			foreach (Tile tile in puzzle!.Tiles)
			{
				if (tile.State == TileState.DEFAULT)
				{
					tile.State = TileState.DISABLED;
				}
			}
		}
		else
		{
			foreach (Tile tile in puzzle!.Tiles)
			{
				if (tile.State == TileState.DISABLED)
				{
					tile.State = TileState.DEFAULT;
				}
			}
		}
	}

	/// <summary>
	/// Persist puzzle data so it isn't queried a second time after page preload
	/// </summary>
	/// <returns></returns>
	private Task PersistPuzzleData()
	{
		ApplicationState.PersistAsJson(nameof(puzzle), puzzle);
		return Task.CompletedTask;
	}

	void IDisposable.Dispose()
	{
		persistingSubscription.Dispose();
	}
}